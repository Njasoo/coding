# 1 绪论
1) 数据元素是数据的基本单位，数据项是组成***数据元素***的最小单位

2) 数据的基本单位是***数据元素***

3) ***树***是非线性数据结构

4) 以下与数据的存储结构无关的术语是

- a) 顺序队列 (顺序)
- b) 链表 (链式)
- ***c) 有序表***
- d) 链栈 (链式)


数据结构，从逻辑上可以把数据结构分成***线性结构***和***非线性结构***

线性结构中数据元素的位置之间存在***一对一***的关系

# 2 复杂度
1) 下面程序段的时间复杂度为(C)，i = 1; while (i <= n) i = i * 3;

- a) O(n)
- b) O(3 * n)
- c) O(log3n)
- d) O(n ^ 3)

2. 算法执行过程中所需要的存储空间成为算法的***空间复杂度***

3. 算法的时间复杂度取决于(C)

   - A 问题的规模
   - B 待处理数据的初态
   - ***A和B***
   - D 都不是

4. for (int i = 1; i <= n; i++) c[i] = i; 该算法的时间复杂度是***O(n)***

5. 下面的时间复杂度

   ````c++
   x = 90, y = 100;
   while (y > 0) {
   	if (x > 100) {
   		x = x - 10
   		y--;
   	} else {
   		x++;
   	}
   }
   ````

   答案：O(1)，因为x，y是固定的

# 3 数组和链表

## 1. 线性表的静态定义

```c++
#define MaxSize 100 // 定义顺序表的最大长度
typedef struct {
    ElemType data[MaxSize];
    int length; // 当前顺序表的长度
} SqList; // 顺序表的类型定义
```

## 2. 线性表的静态初始化

```c++
void InitList(SqList &L) {
    for (int i = 0; i < MaxSize; i++) {
        L.data[i] = 0;
    }
    L.length = 0;
}
// 初始化重点就是干两件事情，就是数组的元素全部初始化为0，然后长度定义为0
```

# 习题

链表的结点类型定义如下

```c++
typedef struct node *link;
struct node {
    ListItem element;
    link left;
    link right;
} *p, *q, *r;
```

**删除双链表结点p的操作是**

```c++
q = p->left; r = p->right; // 先把左右指针保存下来
q->right = r; r->left = q;
```

**双向链表删除pos位置的结点**

```c++
void ListErase(ListNode *pos) {
    assert(pos);
    // 记录前一个和后一个指针
    ListNode *prev = pos->prev;
    ListNode *next = pos->next;
    
    prev->next = next; // pos->prev->next = pos->next;
    next->prev = prev; // pos->next->prev = pos->prev;
    
    free(pos);
    pos = NULL;
    
    // 上一个指针的next指向当前指针的next
    // 下一个指针的prev指向当前指针的prev
}
```

**双链表是有头指针的**



在单链表指针为p的结点之后插入指针为s的结点，正确的操作是

```c++
s->next = p->next; p->next = s;
```



对于一个头指针为head的带头结点的单链表，判断该表为空表的条件是

```c++
head->next == NULL;	
```



线性表采用链式存储时其存储地址

Ans：连续或不连续都可



# 4. 栈



## 习题

1. 给定一个足够大的空栈，进栈序列为ABCD，以CD为开头的出栈序列个数为

   CD固定，后面AB可以，BA不可能，这样的话B就会在出栈序列开头



# 5 队列

定义 顺序队列存储结构

```c++
#define MaxSize 256

typedef struct {
    int data[MaxSize]; // 存放队列元素
    int front, rear; // 队头指针和队尾指针
} SqQueue;
```

循环队列

判空和判满的条件

```c++
队列为空：rear == front
队列为满 (rear + 1) % MaxSize == front
```

## 习题

1. 队列是限定在***端点***进行操作的线性表

2. 最大容量为n的循环队列，队尾指针是rear，队头是front，则队空的条件是（他这个循环队列应该是空了一个位置的）

   ```c++
   rear == front
   ```

3. 队满的条件是

   ```c++
   (rear + 1) % n == front
   ```

4. 进队序列ABCD，出队序列是***ABCD***

5. 栈和队列的共同点：***只允许在端点处插入和删除元素***

6. 用链接方式存储的队列，在进行删除运算时，***头尾指针可能都要修改***。通常都是只用修改队头指针，但是如果删除的是队列中最后一个元素，则会修改队尾指针。

# 串

定义

```c++
#define MAXSIZE 255

typedef struct String {
    char ch[MAXSIZE];
    int length;
} String;
```

## KMP算法

;

# 数组

二维数组内存结构

**行优先存储（就平时经常用的那个）**

内存:

```c++
b[0][1] b[0][1] b[0][2] b[0][3] b[1][0] b[1][1] b[1][2] b[1][3]
```

**列优先存储**

内存：

```c++
b[0][0] b[1][0] b[0][1] b[1][1] b[0][2] b[1][2] b[0][3] b[1][3]
```

行优先存储，M行N列的
$$
b_{ij}的地址为=LOC+ (i * N + j) * sizeof(ElemType)
$$

# 矩阵

压缩矩阵分为特殊矩阵和稀疏矩阵

## 特殊矩阵-对称矩阵

总共需要存储
$$
\sum_{i = 1} ^ {n} i = \frac{n * (n + 1)} {2}
$$
个元素



**是第几个元素（从零开始）**

行优先存储下三角矩阵
$$
index = LOC(i, \space j) = LOC(j, \space i) = \frac{i * (i + 1)} {2} + j
$$
行优先存储上三角矩阵
$$
index = \frac{(2 * n - j - 1) * j} {2} + i
$$
上三角矩阵长这样
$$
\left(
\begin{matrix}
1 & 2 & 3 & 4 \\
0 & 5 & 6 & 7 \\
0 & 0 & 8 & 9 \\
0 & 0 & 0 & 10
\end{matrix}
\right)
$$


列优先存储上三角
$$
index = \frac{j * (j + 1)} {2} + i
$$


### 上三角矩阵

除了对角线和上三角区域，其余元素都相同

行优先存储

key(k): 按行优先的原则，a_ij是第几个元素
$$
k = 
\begin{cases}
\frac{(i-1)*(2n-i+2)}{2}+(j-i),i\le j\\
\frac{n*(n+1)}{2},i>j
\end{cases}
$$


### 下三角矩阵

行优先存储

i,j从1开始
$$
k=
\begin{cases}
\frac{i*(i-1)}{2}+j-1,i \ge j\\
\frac{n(n+1)}{2},i<j
\end{cases}
$$

### 三对角矩阵

三条对角线上的元素

存储空间大小：3n-2
$$
行优先存储，a_{ij}是第几个元素\\
k = 2i-j+3
$$
若已知数组下标k，如何得到i，j
$$
i = \lceil(\frac{k + 2}{3}\rceil\\
j=k-2i+3\\
这我记不住
$$

### 稀疏矩阵

非零元素元素远远少于矩阵元素个数



#### 压缩存储策略

顺序存储：三元组<行，列，值>

链式存储：十字链表法
$$
\begin{array}{|c|c|c|}
\hline
行 & 列 & 值 \\
\hline
\end{array}
$$

$$
\begin{array}{|c|c|}
\hline
指向同列的下一个元素 & 指向同行的下一个元素 \\
\hline
\end{array}
$$



##  习题

1. 在以下描述中，正确的是（B）

   A. 线性表的线性存储结构由于链表存储结构 

   B. 二维数组是其数据元素为线性表的线性表

   C. 栈的操作方式是先进先出

   D. 队列的操作方式是先进后出

2. 对于顺序存储的线性表，访问结点和增加，删除结点的时间复杂度为**O(1), O(n)**

3. 假设有6行8列的二维数组A，每个元素占用6个字节，存储器按字节编址。已知A的基地址为1000，计算：

   (1) 数组A占用多少字节

   **6 * 8 * 6 = 288字节**

   (2) 数组A的最后一个元素的地址

   ```c++
   前面有5行，每行8个元素，第6行已经经过了7个元素
   A[6][8] = 1000 + (5 * 8 + 7) * 6 = 1000 + 47 * 6 = 1000 + 282 = 1282
   ```

   (3) 按行存储时A3,6的地址

   ```c++
   A[0][0] = 1000
   A[3][6] = 1000 + (3 * 8 + 6) * 6 = 1000 + 30 * 6 = 1180
   ```

   (4) 行优先存放时，A1,4的起始地点

   ```(空)
   起始地点什么意思，其实就是地址的意思是吧
   A[1][4] = 1000 + (1 * 8 + 4) * 6 = 1000 + 72 = 1072
   ```

   (5) 列优先存储是，A4,7的起始地点

   ```(空)
   A[4][7] = 1000 + (7 * 6 + 4) * 6 = 1000 + 46 * 6 = 1000 + 276 = 1276
   ```



# 二叉树

$$
二叉树的第i层上最多有2^{i-1}个结点\\
如果二叉树深度为k，那么最多有2^{k-1}个结点\\
n_0=n_2+1\\
其中n0表示度数为0的结点数，n2表示结点为2的结点数 \\
二叉树结点计算公式N=n_0+n_1+n_2 \\
节点总数=总度数+1=0*n_0+1*n_1+2*n_2+...+1 \\
具有n个结点的完全二叉树深度=\color{red}{\lfloor \log_{2}{n} \rfloor + 1}
$$

### 二叉排序树

$$
等概率情况下，查找成功AVL \\
\color{red}AVL = \frac{\sum每一层的节点数*层数}{总结点个数}
$$

# 查找表

平均查找长度
$$
ASL = \sum_{i = 1}^{n}P_iC_i
$$
其中Pi是查找r[i]的概率

C[i]是查找r[i]所需比较关键字的次数

监视哨就是把r[0]设置为key的副本，然后查找的时候就可以不用判断是否越界，只需要判断是否相等，可以少一个判断，减少大约一半的时间，常数优化吧
$$
对于n个记录的表，所需比较关键字的次数 \\
只考虑查找成功，最少为1，最多为n \\
假定每个记录的查找概率相等 \\
即P_1 = P_2 = P_3 = ... = P_n = \frac{1}{n} \\
ASL = \sum_{i = 1} ^ {n} {P_i C_i} = \frac{1}{n} \sum_{i = 1}^{n} {C_i} = \frac{1}{n}(n + (n - 1) + ... + 1) = \frac{1}{n} * \frac{n * (n + 1)}{2} = \frac{n + 1} {2}
$$
如果考虑了查找失败，假设查找失败和查找成功的概率相等
$$
ASL = \frac{1}{2n} \sum_{i = 1}^{n} C_i + \frac{n + 1} {2} = \frac{n + 1}{4} + \frac{n + 1}{2} = \frac{3(n + 1)}{4}
$$

# 图

## 关键路径

是指项目中时间最长的互动顺序，决定着可能的项目最短工期

就是从起点到重点的最长路径



# 分块查找

块内无序，块间有序

创建一个索引表
$$
\begin{array}{|c|c|c|}
\hline
25 & 58 & 88 \\
\hline
 & & \\
\hline
\end{array}
$$
第一行：各块内的最大关键字

第二行：各块的起始地址

根据关键字确定数据在哪个块中，然后在块内做顺序查找
$$
假设， 长度为n的查找表被均匀地分为b块, 每块s个元素
设索引查找和块内查找的平均查找长度为, L_I, L_S, 则分块查找的平均查找长度为 \\
ASL=L_I+L_S\\
用顺序查找查索引表, 则L_I=\frac{1+2+...+b}{b}=\frac{b+1}{2}, L_S=\frac{1+2+...+s}{s}=\frac{s+1}{2}
则ASL=\frac{b+1}{2}+\frac{s+1}{2}=\frac{b+s+2}{2}\\
=\frac{sb+s^2+2s}{2s}=\frac{s^2+2s+n^2}{2s}\\
可得当s=\sqrt{n}时, ASL最小
$$

# 平均查找长度-折半查找法

查找成功: 先画出查找成功的二叉树, 现在树上拥有的结点, 标记为成功的结点

查找失败: 在查找成功的二叉树的基础上, 补充结点缺少的孩子, 这个缺少的就是查找失败的情况, 这些新补充的结点, 标记为失败的结点
$$
AVL_{成功}=\frac{\sum{每一层的结点数*层数}}{成功的结点数}\\
AVL_{失败}=\frac{\sum{每一层的节点数*层数}}{失败的结点数}\\
注意: 失败的结点所在的层数并不是实际在二叉树上的层数, 而是看父节点所在的层数
$$
