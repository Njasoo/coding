#include <bits/stdc++.h>
using namespace std;
#define db(x) cerr << #x << " = " << x << endl
// 题目在暗示我线段树？
// 每次操作就是选连续的k个数字，然后同时加上某个数c，问是否可能若干次操作后存在全部变成零的情况
// 感觉不是线段树，题目在误导？
// 考虑把范围里的数字全部加起来，如果结果全部是0的话，那么总和也是0
// r - l + 1 == len，每次操作，总和增加len * c，那就在问是否存在len * (c1 + c2 + ... + clen) == sum
// 数论问题吧，c1 + c2 + ... + clen必须是整数，那么sum / len也是整数，所以sum % len == 0，这就完了吗
// 应该是需要前缀和优化一下时间复杂度
// 错了，为什么。。。忘记前缀和了
// case1 错了
// 小于len的情况需要特别去处理吗
// 搞错了是K,把len换成k就好
// 还是错
// 想错了，总和为0不等于全部为0，还要满足什么条件，还是方向是错的
// 需要的是一个O(log(N))或者O(1)的解法
// 是存在性问题，所以我并不需要实际去计算它是怎么操作的，但是每次都要k个k个的加，就很烦
// 有没有可能一定一步到位 显然不能
// 全部为零还可以等价于什么呢
// 在等于零的基础上再做点什么？
// 有没有可能所有的数都要满足一个什么性质，比如同余某个数 看不出来
// 但是总和为零是必要条件，至少可以判断No是没错的
// 也许是在yes再加一个判断
// 观察到如果k大于区间的一半，那么一定有那么几个数它的增量一定是-(c1+c2+...+clen) 但我也不能检查这所有的数吧
// 全部为零的另一个必要条件，它的任何子区间都可以变成总和为0
// 总和可为零的条件就是sum % k == 0
// 前缀和好判断，但是任意区间怎么判断，判断的条件前提是，区间长度大于等于k
// 直接预处理所有区间？区间长度k ~ n
// 每个大区间是否可全部为0，取决于包含于它的小区间是否可为0，所以，预处理所有长度为k的小区间？
// 一个区间会有多少个小区间，len - k + 1 ?，如果一个小区间可以总和为0，标记为1，否则标记为0，如果小区间标记总和为len - k + 1
// 说明全部都可为0，但是如何表示一个小区间，左端点好了，那个一个区间的小区间就是l ~ r - k + 1（左端点）
// 怎么全是NO，应该只会多判yes的啊，改了错误还是NO
// sum2的意义好像还不是很明确，意义是所有左端点<=i的小区间总共有多少个
// 这个方法好像不行，每次操作不一定每个小区间就是被加了k个数，操作貌似不可以拆分
// 这个题感觉是想不出来了
// 试一下之前的另外一个观察吧
// 如果有几个数的增量是-sum / k，那么重叠的部分，数字一定相等？
// 如何计算重叠部分，左右端点延伸一下就好，最左延伸到右边就是l + k - 1, 最右延伸到左边就是r - k + 1, r - k + 1 ~ l + k - 1就是重叠的部分
// 解出r - l <= 2 * k - 2时有重叠部分，能不能搞一个判断一个区间的数全部相等的一颗线段树，好像可以，但是是否这样就解决了，我不是很清楚
// woc这个线段树真的可以写出来吗, 一个区间是否全部数字相等不就是等价于最小值等于最大值咯，被自己搞了一波，st表好了
// 还是错，比赛结束了，看题解吧
// 差分数组？一个区间[i, j]进行一次操作的话，相当于d[i] += c, d[j + 1] -= c
// d[i] += c, d[i + k] -= c，它们的对于k的余数不变，有什么用吗
// 另外一点就是他们的坐标mod k同余，也就是说对于所有i % k == j(0 <= j < k)的d[i]，他们的和是不变的
// 最后全部a[i]都等于0，也就是说所有sigma(d[i]) = a[i]都等于零，意味着所有d[i]都等于0？ 这不是一样难度的问题？
// 这又有什么用，能说操作完差分数组总和不变吗？ 如果是的话，那差分数组总和必须一开始就等于0？ 感觉好像不太对的样子
// 每一次操作都是成对的
// 对于所有i % k == j的d[i]总和全部都是0，这句话就应该是对的，那么怎么检查呢
// 可以提前处理d[j]的总和(i % k == j)
// 对于每一次询问，[l, r], 里面包含了那些余数，注意到区间是连续的，所有如果区间长度为k，不对不对，搞错了
// 每次询问就相当于要重新看待一个新数列，但是能不能透过像是前缀和的方式快速得到新区间内d[i % k == j]的总和
// 好像可以，sum[i] = sum[i - k] + d[i]; 然后j = 1 ~ k的数就等于自己 因为i 和 i - k同余
// k最多10！，woc，那不直接暴力查询
// 但是总和又是什么意思，我又卡住了，是全部，不要忘了差分的意义
// 关键就是要抓住不变量，操作是可变的，无穷的
// 糟了不知道代码怎么写
// 艹,sigma(d[i])不就是等于a[i]吗，等等等等，我有点懵了
// sum[i][j]表示坐标%k==j的前缀和
// a[i]全为0为什么等价于d[l+1, r]全为0
// 为什么左端点要特判
// 哦，因为a[l]要等于0的话，sigma(d[l])应该等于-a[l - 1]
// 其他的d[i]在这基础上全部为0，(r + 1) % k在范围外，任意取数
const int N = 2e5 + 5;
long long a[N], d[N], sum[N][10];
int n, k;
int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin >> n >> k;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        d[i] = a[i] - a[i - 1];
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j < k; j++) {
            sum[i][j] = sum[i - 1][j] + (i % k == j ? d[i] : 0);
        }
    }
    int q;
    cin >> q;
    while (q--) {
        int l, r;
        cin >> l >> r;
        bool flag = 1;
        for (int j = 0; j < k; j++) {
            if (j == (r + 1) % k) continue;
            if (l % k == j && sum[r][j] - sum[l - 1][j] != -a[l - 1]) {
                flag = 0;
                break;
            }
            if (sum[r][j] - sum[l - 1][j] != 0) {
                flag = 0;
                break;
            }
        }
        cout << (flag ? "Yes" : "No") << '\n';
    }
    return 0;
}